{
    parserClass="com.intellij.lang.graql.parser.GraqlParser"
    parserUtilClass="com.intellij.lang.parser.GeneratedParserUtilBase"

    extends="com.intellij.extapi.psi.ASTWrapperPsiElement"
    extends(".*Pattern")=pattern

    psiClassPrefix="Graql"
    psiImplClassSuffix="Impl"
    psiPackage="com.intellij.lang.graql.psi"
    psiImplPackage="com.intellij.lang.graql.psi.impl"
    psiImplUtilClass="com.intellij.lang.graql.psi.impl.GraqlPsiImplUtil"

    elementTypeHolderClass="com.intellij.lang.graql.psi.GraqlTokenTypes"
    elementTypeClass="com.intellij.lang.graql.psi.GraqlElementType"
    tokenTypeClass="com.intellij.lang.graql.psi.GraqlTokenType"

    tokens=[
        AT                  = '@'
        LBR                 = '['
        RBR                 = ']'
        period              = '.'
        colon               = ':'
        semicolon           = ';'
        comma               = ','
        LPAREN              = '('
        RPAREN              = ')'
        LBRACE              = '{'
        RBRACE              = '}'
        LESS                = '<'
        LESSEQ              = '<='
        GREATER             = '>'
        GREATEREQ           = '>='
        EQ                  = '='
        NEQ                 = '!='
        sub_keyword                 = 'sub'
        key_keyword                 = 'key'
        has_keyword                 = 'has'
        plays_keyword               = 'plays'
        relates_keyword             = 'relates'
        role_keyword                = 'role'
        relationship_keyword        = 'relationship'
        entity_keyword              = 'entity'
        attribute_keyword           = 'attribute'
        datatype_keyword            = 'datatype'
        long_keyword                = 'long'
        double_keyword              = 'double'
        string_keyword              = 'string'
        date_keyword                = 'date'
        boolean_keyword             = 'boolean'
        via_keyword                 = 'via'
        isa_keyword                 = 'isa'
        commit_keyword              = 'commit'
        define_keyword              = 'define'
        undefine_keyword            = 'undefine'
        insert_keyword              = 'insert'
        match_keyword               = 'match'
        rule_keyword                = 'rule'
        when_keyword                = 'when'
        then_keyword                = 'then'
        get_keyword                 = 'get'
        compute_keyword             = 'compute'
        cluster_keyword             = 'cluster'
        in_keyword                  = 'in'
        member_keyword              = 'member'
        label_keyword               = 'label'
        is_abstract_keyword         = 'is-abstract'
        as_keyword                  = 'as'
        delete_keyword              = 'delete'
        aggregate_keyword           = 'aggregate'
        ask_keyword                 = 'ask'
        count_keyword               = 'count'
        sum_keyword                 = 'sum'
        max_keyword                 = 'max'
        min_keyword                 = 'min'
        mean_keyword                = 'mean'
        median_keyword              = 'median'
        group_keyword               = 'group'
        of_keyword                  = 'of'
        std_keyword                 = 'std'
        contains_keyword            = 'contains'
        and_keyword                 = 'and'
        or_keyword                  = 'or'
        offset_keyword              = 'offset'
        limit_keyword               = 'limit'
        order_keyword               = 'order'
        by_keyword                  = 'by'
        asc_keyword                 = 'asc'
        desc_keyword                = 'desc'
        true_keyword                = 'true'
        false_keyword               = 'false'
        for_keyword                 = 'for'
        do_keyword                  = 'do'
        if_keyword                  = 'if'
        not_keyword                 = 'not'
        else_keyword                = 'else'
        elseif_keyword              = 'elseif'
        null_keyword                = 'null'
        id_keyword                  = 'id'
        degrees_keyword             = 'degrees'
        path_keyword                = 'path'
        paths_keyword               = 'paths'
        from_keyword                = 'from'
        to_keyword                  = 'to'
        regex_keyword               = 'regex'
        size_keyword                = 'size'
        int_keyword                 = 'int'
        noescp_keyword              = 'noescp'
        equals_keyword              = 'equals'

        STRING_LITERAL      = "regexp:('([^'\\]|\\.)*'|\"([^\"\\]|\\.)*\")"
        REGEX               = "regexp:/([^\\\/]+)/"
        INTEGER             = "regexp:([-+]?\d+)"
        REAL                = "regexp:([-+]?\d+.\d+)"
        space               = 'regexp:\s+'
        single_line_comment = 'regexp:#.*'
        ID                  = 'regexp:[a-zA-Z_0-9-]*'
        VARIABLE            = 'regexp:\$[a-zA-Z0-9_-]*'
    ]
}

GraqlFile ::= !<<eof>> (query)*

query ::= (deleteQuery | aggregateQuery | getQuery | insertQuery | defineQuery | undefineQuery | computeQuery | statement) commit_keyword?

matchPart ::= match_keyword patterns (matchLimitOffset|matchOffsetLimit)? matchOrderBy? blockContents?
matchLimitOffset ::= matchLimit matchOffset?
matchOffsetLimit ::= matchOffset matchLimit?
matchLimit ::= limit_keyword INTEGER ';' // matchLimit
matchOffset ::= offset_keyword INTEGER ';' // matchOffset
matchOrderBy ::= order_keyword by_keyword VARIABLE (asc_keyword|desc_keyword)? ';' // matchOrderBy

deleteQuery ::= matchPart delete_keyword variables? ';'
aggregateQuery ::= matchPart aggregate_keyword aggregate ';'
getQuery ::= matchPart (get_keyword (VARIABLE (',' VARIABLE)*)? ';')?
insertQuery ::= matchPart? insert_keyword varPatterns? (labelOrVar? blockContents?)
defineQuery ::= define_keyword varPatterns
undefineQuery ::= undefine_keyword varPatterns
computeQuery ::= compute_keyword computeMethod

variables ::= VARIABLE (',' VARIABLE)*

computeMethod ::= min | max | median | mean | std | sum | count | path | paths | cluster | degrees

min ::= min_keyword         of_keyword ofList                               (in_keyword inList)? ';'
max ::= max_keyword         of_keyword ofList                               (in_keyword inList)? ';'
median ::= median_keyword   of_keyword ofList                               (in_keyword inList)? ';'
mean ::= mean_keyword       of_keyword ofList                               (in_keyword inList)? ';'
std ::= std_keyword         of_keyword ofList                               (in_keyword inList)? ';'
sum ::= sum_keyword         of_keyword ofList                               (in_keyword inList)? ';'
degrees ::= degrees_keyword (of_keyword ofList)?                            (in_keyword inList)? ';'
cluster ::= cluster_keyword (of_keyword identifier    )?                    (in_keyword inList)? ';' clusterParam*
path ::= path_keyword       from_keyword identifier to_keyword identifier   (in_keyword inList)? ';'
paths ::= paths_keyword     from_keyword identifier to_keyword identifier   (in_keyword inList)? ';'
count ::= count_keyword                                                     (in_keyword inList)? ';'

clusterParam ::= MEMBERS ';'    // clusterMembers
   | SIZE INTEGER ';'           // clusterSize

ofList ::= labelList
inList ::= labelList
labelList ::= label (',' label)*

aggregate ::= labelOrVar argument*      // customAgg
    | '(' namedAgg (',' namedAgg)* ')'  // selectAgg
argument ::= VARIABLE  // variableArgument
    | aggregate        // aggregateArgument
namedAgg ::= aggregate as_keyword identifier

patterns ::= (pattern (','|';')?)+
pattern ::= varPattern          // varPatternCase
    | orPattern                 // orPattern
    | andPattern                // andPattern
andPattern ::= LBRACE patterns RBRACE
orPattern ::= pattern or_keyword pattern

varPatterns ::= (varPattern ';'?)+
varPattern ::= labelOrVar? property (','? property blockContents?)*

property ::= isa_keyword labelOrVar             // isa
    | isa_keyword escapedExpression           // isa
    | sub_keyword labelOrVar                    // sub
    | relates_keyword labelOrVar                // relates
    | plays_keyword labelOrVar                  // plays
    | id_keyword identifier                   // propId
    | label_keyword label                     // propLabel
    | when_keyword LBRACE patterns RBRACE     // propWhen
    | then_keyword LBRACE varPatterns RBRACE  // propThen
    | has_keyword label escapedExpression     // propHas
    | has_keyword label predicate             // propHas
    | has_keyword labelOrVar                    // propResource
    | has_keyword property                    // propHasProp?
    | key_keyword labelOrVar                    // propKey
    | '(' casting (',' casting)* ')'    // propRel
    | is_abstract_keyword                     // isAbstract
    | datatype_keyword (long_keyword|double_keyword|string_keyword|boolean_keyword|date_keyword)  // propDatatype
    | regex_keyword REGEX                     // propRegex
    | NEQ labelOrVar                     // propNeq
    | ';'

casting ::= labelOrVar (':' VARIABLE)?
    | labelOrVar VARIABLE

labelOrVar ::= label | VARIABLE
    | min_keyword | max_keyword | median_keyword | mean_keyword | std_keyword | sum_keyword | count_keyword
    | path_keyword | cluster_keyword | date_keyword | degrees_keyword | member_keyword | size_keyword
    | entity_keyword | relationship_keyword | rule_keyword | role_keyword | attribute_keyword

predicate ::= EQ? value                // predicateEq
    | EQ? VARIABLE                     // predicateVariable
    | NEQ valueOrVar                   // predicateNeq
    | '>' valueOrVar                    // predicateGt
    | '>=' valueOrVar                   // predicateGte
    | '<' valueOrVar                    // predicateLt
    | '<=' valueOrVar                   // predicateLte
    | contains_keyword (STRING_LITERAL | VARIABLE)    // predicateContains
    | REGEX                             // predicateRegex
valueOrVar ::= VARIABLE // valueVariable
    | value             // valuePrimitive
value ::= STRING_LITERAL   // valueString
   | INTEGER  // valueInteger
   | REAL     // valueReal
   | (true_keyword|false_keyword)  // valueBoolean
   | DATE     // valueDate
   | DATETIME // valueDateTime

label ::= identifier | IMPLICIT_IDENTIFIER

identifier ::= ID | STRING_LITERAL {
    mixin="com.intellij.lang.graql.psi.impl.GraqlNamedElementImpl"
    implements="com.intellij.lang.graql.psi.GraqlNamedElement"
    methods=[getName setName getNameIdentifier]
}

//Graql template extension
escapedExpression ::= untypedExpression;
untypedExpression ::= '<' identifier accessor* '>'                      //idExpression
    | MACRO_NOESCP
    | MACRO_EQUALS
    | ID_MACRO LPAREN expression? (',' expression)* RPAREN accessor?    //macroExpression
    | identifier

ID_MACRO ::= AT (MACRO_NOESCP|ID|int_keyword|long_keyword|double_keyword|boolean_keyword|date_keyword)
MACRO_NOESCP ::= AT noescp_keyword LPAREN expression? (',' expression)* RPAREN accessor? identifier?
MACRO_EQUALS ::= AT equals_keyword LPAREN expression? (',' expression)* RPAREN accessor?

accessor ::= period identifier     //mapAccessor
    | LBR int_ RBR      //listAccessor

block ::= LBRACE blockContents RBRACE ';'?
blockContents ::= (statement | escapedExpression | query | patterns)*

statement ::= forInStatement
    | forEachStatement
    | ifStatement

forInStatement   ::= for_keyword LPAREN identifier in_keyword escapedExpression RPAREN do_keyword block
forEachStatement ::= for_keyword LPAREN escapedExpression RPAREN do_keyword block

ifStatement   ::= ifPartial elseIfPartial* elsePartial?
ifPartial     ::= if_keyword LPAREN bool RPAREN do_keyword block
elseIfPartial ::= elseif_keyword LPAREN bool RPAREN do_keyword block
elsePartial   ::= else_keyword block

expression    ::= untypedExpression | nil | STRING_LITERAL | number | (true_keyword|false_keyword)
number        ::= untypedExpression | int_ | double_
int_          ::= untypedExpression | INTEGER //huh?
double_       ::= untypedExpression | DOUBLE //huh?
list          ::= untypedExpression
nil           ::= null_keyword
bool ::= expression EQ expression           //eqExpression
    | expression NEQ expression             //NEQExpression
    | number GREATER number                 //greaterExpression
    | number GREATEREQ number               //greaterEqExpression
    | number LESS number                    //lessExpression
    | number LESSEQ number                  //lessEqExpression
    | untypedExpression                     //booleanExpression
    | (true_keyword|false_keyword)                          //booleanConstant
    | orBool
    | andBool
    | notBool
    | groupBool
groupBool ::= LPAREN bool RPAREN
orBool ::= groupBool or_keyword groupBool
andBool ::= groupBool and_keyword groupBool
notBool ::= not_keyword groupBool